{
  "name": "co",
  "version": "1.5.2",
  "description": "generator async flow control goodness",
  "keywords": [
    "async",
    "flow",
    "generator",
    "coro",
    "coroutine"
  ],
  "devDependencies": {
    "should": "~1.2.2",
    "mocha": "~1.12.0",
    "q": "~0.9.4",
    "bench": "~0.3.5"
  },
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/visionmedia/co.git"
  },
  "readme": "# Co\n\n  Generator based flow-control goodness for nodejs (and soon the browser), using\n  thunks _or_ promises, letting you write non-blocking code in a nice-ish\n  way.\n\n  Currently you must use the `--harmony-generators` flag when\n  running node 0.11.x to get access to generators.\n\n  Co is careful to relay any errors that occur back to the generator, including those\n  within the thunk, or from the thunk's callback. \"Uncaught\" exceptions in the generator are\n  then either passed `co()`'s thunk or thrown.\n\n  Make sure to view the [examples](https://github.com/visionmedia/co/tree/master/examples).\n\n## Installation\n\n```\n$ npm install co\n```\n\n## Associated libraries\n\n  - [co-fs](https://github.com/visionmedia/co-fs) - core `fs` function wrappers\n  - [co-exec](https://github.com/visionmedia/co-exec) - core `exec` function wrapper\n  - [co-prompt](https://github.com/visionmedia/co-prompt) - terminal user input utilities\n  - [co-express](https://github.com/mciparelli/co-express) - [express](https://github.com/visionmedia/express) wrapper that enables generators to be used as middlewares\n  - [level-co](https://github.com/juliangruber/level-co) - levelup wrapper\n  - [mysql-co](https://github.com/sidorares/mysql-co) - mysql wrapper\n  - [co-each](https://github.com/juliangruber/co-each) - parallel foreach\n  - [co-wait](https://github.com/juliangruber/co-wait) - setTimeout wrapper\n\n## Example\n\n```js\nvar co = require('co');\n\nco(function *(){\n  var a = yield get('http://google.com');\n  var b = yield get('http://yahoo.com');\n  var c = yield get('http://cloudup.com');\n  console.log(a.status);\n  console.log(b.status);\n  console.log(c.status);\n})\n\nco(function *(){\n  var a = get('http://google.com');\n  var b = get('http://yahoo.com');\n  var c = get('http://cloudup.com');\n  var res = yield [a, b, c];\n  console.log(res);\n})\n```\n\n## Yieldables\n\n  The \"yieldable\" objects currently supported are:\n\n  - promises\n  - thunks (functions)\n  - array (parallel execution)\n  - generators (delegation)\n  - generator functions (delegation)\n\n## Thunks vs promises\n\n  While co supports promises, you may return \"thunks\" from your functions,\n  which otherwise behaves just like the traditional node-style callback\n  with a signature of: `(err, result)`.\n\n\n  For example take `fs.readFile`, we all know the signature is:\n\n```js\nfs.readFile(path, encoding, function(err, result){\n\n});\n```\n\n  To work with Co we need a function to return another function of\n  the same signature:\n\n```js\nfs.readFile(path, encoding)(function(err, result){\n\n});\n```\n\n  Which basically looks like this:\n\n```js\nfunction read(path, encoding) {\n  return function(cb){\n    fs.readFile(path, encoding, cb);\n  }\n}\n```\n\n  This is what the `co.wrap(fn)` utility function does for you.\n\n## Receiver propagation\n\n  When `co` is invoked with a receiver it will propagate to most yieldables,\n  allowing you to alter `this`.\n\n```js\nvar ctx = {};\n\nfunction foo() {\n  assert(this == ctx);\n}\n\nco.call(ctx, function *(){\n  assert(this == ctx);\n  yield foo;\n});\n```\n\n## API\n\n### co(fn)\n\n  Pass a generator `fn` which is immediately invoked. Any `yield` expressions\n  within _must_ return a \"thunk\", at which point `co()` will defer execution.\n\n```js\nvar co = require('co');\nvar fs = require('fs');\n\nfunction read(file) {\n  return function(fn){\n    fs.readFile(file, 'utf8', fn);\n  }\n}\n\nco(function *(){\n  var a = yield read('.gitignore');\n  var b = yield read('Makefile');\n  var c = yield read('package.json');\n  console.log(a);\n  console.log(b);\n  console.log(c);\n});\n```\n\n  You may also yield `Generator` objects to support nesting:\n\n\n```js\nvar co = require('co');\nvar fs = require('fs');\n\nfunction size(file) {\n  return function(fn){\n    fs.stat(file, function(err, stat){\n      if (err) return fn(err);\n      fn(null, stat.size);\n    });\n  }\n}\n\nfunction *foo(){\n  var a = yield size('.gitignore');\n  var b = yield size('Makefile');\n  var c = yield size('package.json');\n  return [a, b, c];\n}\n\nfunction *bar(){\n  var a = yield size('examples/parallel.js');\n  var b = yield size('examples/nested.js');\n  var c = yield size('examples/simple.js');\n  return [a, b, c];\n}\n\nco(function *(){\n  var a = yield foo();\n  var b = yield bar();\n  console.log(a);\n  console.log(b);\n});\n```\n\n  Or if the generator functions do not require arguments, simply `yield` the function:\n\n```js\nvar request = require('superagent');\n\nvar get = co.wrap(request.get);\n\nfunction *results() {\n  var a = yield get('http://google.com')\n  var b = yield get('http://yahoo.com')\n  var c = yield get('http://ign.com')\n  return [a.status, b.status, c.status]\n}\n\nco(function *(){\n  // 3 concurrent requests at a time\n  var a = yield results;\n  var b = yield results;\n  var c = yield results;\n  console.log(a, b, c);\n\n  // 9 concurrent requests\n  console.log(yield [results, results, results]);\n});\n```\n\n#### co() return values\n\n  Since `co()` returns a thunk, you may pass a function to this thunk\n  to receive the `return` values from the generator. Any error that occurs\n  is passed to this (`sizes`) function.\n\n```js\n\nvar co = require('co');\nvar fs = require('fs');\n\nvar read = co.wrap(fs.readFile);\n\nvar sizes = co(function *(){\n  var a = yield read('.gitignore');\n  var b = yield read('Makefile');\n  var c = yield read('package.json');\n  return [a.length, b.length, c.length];\n});\n\nsizes(function(err, res){\n  console.log(res);\n});\n```\n\n### co.wrap(fn, [ctx])\n\n  The `co.wrap()` utility simply wraps a node-style function to return a thunk.\n\n```js\n\nvar co = require('co');\nvar fs = require('fs');\n\nvar read = co.wrap(fs.readFile);\n\nco(function *(){\n  var a = yield read('.gitignore');\n  var b = yield read('Makefile', 'ascii');\n  var c = yield read('package.json', 'utf8');\n  console.log(a);\n  console.log(b);\n  console.log(c);\n});\n```\n\nAn example with redis:\n\n```js\n\nvar co = require('co')\nvar redis = require('redis')\nvar db = redis.createClient()\n\ndb.set = co.wrap(db.set)\ndb.get = co.wrap(db.get)\n\nco(function *(){\n  yield db.set('foo', 'bar')\n  yield db.set('bar', 'baz')\n\n  var res = yield db.get('foo')\n  console.log('foo -> %s', res);\n\n  var res = yield db.get('bar')\n  console.log('bar -> %s', res);\n})\n```\n\n### co.join(fn...)\n\n  The `co.join()` utility function allows you to pass multiple thunks, or an array\n  of thunks and \"join\" them all into a single thunk which executes them all concurrently,\n  instead of in sequence. Note that the resulting array ordering _is_ retained.\n\n```js\n\nvar co = require('co');\nvar join = co.join;\nvar fs = require('fs');\n\nfunction size(file) {\n  return function(fn){\n    fs.stat(file, function(err, stat){\n      if (err) return fn(err);\n      fn(null, stat.size);\n    });\n  }\n}\n\nco(function *(){\n  var a = size('.gitignore');\n  var b = size('index.js');\n  var c = size('Makefile');\n  var res = yield join(a, b, c);\n  console.log(res);\n  // => [ 13, 1687, 129 ]\n});\n```\n\n  As an alias of `join(array)` you may simply `yield` an array:\n\n```js\nco(function *(){\n  var a = size('.gitignore');\n  var b = size('index.js');\n  var c = size('Makefile');\n  var res = yield [a, b, c];\n  console.log(res);\n  // => [ 13, 1687, 129 ]\n});\n```\n\n  Nested joins may also be expressed as simple nested arrays:\n\n```js\nvar a = [\n  get('http://google.com'),\n  get('http://yahoo.com'),\n  get('http://ign.com')\n];\n\nvar b = [\n  get('http://google.com'),\n  get('http://yahoo.com'),\n  get('http://ign.com')\n];\n\nconsole.log(yield [a, b]);\n```\n\n### Performance\n\n  On my machine 30,000 sequential stat()s takes an avg of 570ms,\n  while the same number of sequential stat()s with `co()` takes\n  610ms, aka the overhead introduced by generators is _extremely_ negligable.\n\n## License\n\n  MIT\n\n",
  "readmeFilename": "Readme.md",
  "bugs": {
    "url": "https://github.com/visionmedia/co/issues"
  },
  "homepage": "https://github.com/visionmedia/co",
  "_id": "co@1.5.2",
  "dist": {
    "shasum": "58c6d84e664fc82e363d12f36afbf3dc8d0b4879"
  },
  "_from": "co@~1.5.1",
  "_resolved": "https://registry.npmjs.org/co/-/co-1.5.2.tgz"
}
