{
  "name": "chanel",
  "version": "2.2.0",
  "description": "Channel-based control-flow for parallel tasks with concurrency control",
  "repository": {
    "type": "git",
    "url": "git://github.com/cojs/chanel"
  },
  "author": {
    "name": "Jonathan Ong",
    "email": "me@jongleberry.com",
    "url": "http://jongleberry.com"
  },
  "license": "MIT",
  "main": "lib/index.js",
  "dependencies": {
    "co": "*",
    "generator-supported": "*",
    "to-descriptor": "*"
  },
  "devDependencies": {
    "co-wait": "*",
    "mocha": "*",
    "should": "*",
    "gnode": "*"
  },
  "scripts": {
    "test": "NODE=gnode make test"
  },
  "readme": "# chanel [![Build Status](https://travis-ci.org/cojs/chanel.png)](https://travis-ci.org/cojs/chanel)\n\nJavascript concurrency and order-preserving channels. You can consider this a streaming `async.parallel` with concurrency control that returns results __in the correct order__. Or a transform stream that executes multiple \"transforms\" at once.\n\nThis is very similar to other libraries like [batch](https://github.com/visionmedia/batch) and [co-queue](https://github.com/segmentio/co-queue) except:\n\n- You can push jobs and pull data while tasks are in progress\n- You don't have to wait until all the callbacks are finished to start reading data\n- You don't have to wait until you define all or even any callbacks to begin reading\n- Concurrency control (`Infinity` by default)\n- Data will always be returned in the correct order\n- You can discard data\n\nThe general use-case is concatenating files (as the example above).\n\n```js\nvar chanel = require('chanel')\n\nco(function* () {\n  var ch = chanel()\n  // only two file descriptors open at a time\n  ch.concurrency = 2\n\n  var files = [\n    '1.txt',\n    '2.txt',\n    '3.txt',\n    '4.txt',\n    '5.txt',\n    '6.txt',\n  ]\n\n  // create and push the functions or \"tasks\"\n  files.forEach(function (filename) {\n    ch.push(function (done) {\n      fs.readFile(filename, 'utf8', done)\n    })\n  })\n\n  while (ch.readable) {\n    // write each file to stdout in order\n    process.stdout.write(yield ch)\n  }\n\n  // exit the process (unnecessary)\n  process.exit()\n})()\n```\n\nor concatenate them all with:\n\n```js\nvar results = yield ch(true)\nvar string = results.join('')\n```\n\nFor this specific example, you're better off using [combine-streams](https://github.com/stream-utils/combine-streams), but there are use-cases where you need to buffer the entire file such as build systems with compilation steps.\n\n## API\n\n### var ch = chanel([options])\n\n- `concurrency` <Infinity> - maximum number of concurrent callbacks\n- `discard` <false> - discard the results of the callbacks. Will only throw errors, if any, if `true`.\n- `closed` or `open` - by default, the channel is closed, meaning `yield ch(true)` will flush only the remaining callbacks. If opened, `yield ch(true)` will not yield until the channel is closed.\n\n### ch.push(fn)\n\nPush a thunk to the channel. If the thunk returns multiple arguments, it will be sliced into an array (just like co).\n\n### var result = yield ch\n\nPull the next value in the channel. This waits for the next result in the channel indefinitely whether or not the channel is closed.\n\nIf an error was thrown, this function will return that error, and no more additional callbacks will be executed. To continue executing callbacks, just `yield ch` again.\n\nIf `ch.discard === false`, errors will be returned in the correct order. Otherwise, errors will be returned ASAP.\n\nNote that this is a function. If you are not using generators, you can do something recursive like:\n\n```js\nch(function next(err, res) {\n  if (err) throw err;\n  if (res) console.log(res);\n  if (ch.readable) ch(next);\n  process.exit();\n});\n```\n\nWhen using `co` generators, you can just `yield` it.\n\n```js\nco(function* () {\n  while (ch.readable) console.log(yield ch);\n})\n```\n\n### var results = yield ch(true)\n\nWaits until all the pending callbacks are completed. I personally call this \"flushing the channel\". Unless you are discarding data, all the results of the callbacks will be returned as the array `results`.\n\nThis is essentially the \"give me everything method\". Without generators, you can do:\n\n```js\nch(true, function (err, results) {\n\n})\n```\n\n### ch.queue\n\nNumber of results waiting to be read.\n\n### ch.readable\n\nA boolean to check whether you can `yield* ch.read()`. Otherwise, a `yield* ch.read()` call may never be yielded.\n\n### ch.closed\n\nWhether the channel is closed. `true` by default.\n\n### ch.open()\n\nOpens the channel. When the channel is opened, `yield ch(true)` will not `yield` until the channel is closed.\n\n### ch.close()\n\nCloses the channel.\n\n### yield ch.pushed\n\nIf the channel is closed, `yield`s immediately.\nIf the channel is opened, returns `true` if data has been pushed and returns `false` if the channel has been closed, which means there is no data to read.\n\nIf you're using an open channel, you want to wait until `yield ch.pushed` before you start reading the data.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/cojs/chanel/issues"
  },
  "homepage": "https://github.com/cojs/chanel",
  "_id": "chanel@2.2.0",
  "_from": "chanel@^2.0.2"
}
