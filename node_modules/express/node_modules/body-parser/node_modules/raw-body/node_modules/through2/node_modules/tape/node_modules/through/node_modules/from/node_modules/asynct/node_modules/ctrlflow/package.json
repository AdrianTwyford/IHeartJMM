{
  "name": "ctrlflow",
  "description": "yet another async control flow lib",
  "version": "0.0.3",
  "homepage": "https://github.com/dominictarr/ctrlflow",
  "repository": {
    "type": "git",
    "url": "git://github.com/dominictarr/ctrlflow.git"
  },
  "author": {
    "name": "Dominic",
    "email": "dominic.tarr@gmail.com"
  },
  "main": "./ctrlflow.js",
  "directories": {
    "lib": "."
  },
  "dependencies": {
    "curry": "0.0.x"
  },
  "devDependencies": {
    "meta-test": ">=0.0.2",
    "it-is": "*",
    "curry": "*"
  },
  "scripts": {
    "test": "meta-test test/*.js"
  },
  "engines": {
    "node": ">=0.2.0"
  },
  "readme": "#yet another nodejs async control flow lib#\n\nthere are already a number of ndoejs control flow libs, notably, creationix/step and substack/seq and i've investigated them, but decided it's worth inventing your own, so that \n\n  1. you really understand how it works.\n  \ncontrol flow is so fundamential... it best to deeply understand it. so, I'm writing my own, and I suspect you should too.\n\n##group##\n\ncollect the results of a number of async functions:\n\n    var g = require('ctrlflow').group()\n\n    func1(args,g())//g() will return a function collect it's args for g.done\n    func2(args,g())\n    func3(args,g())\n\n    g.done(function (){\n      console.log(\"func1,2,3 called back\")\n    })\n\nalso, you can pass the calback directly into group():\n\n    var g = require('ctrlflow').group(function (){\n      console.log(\"func1,2,3 called back\")\n    })\n\n    func1(args,g())//g() will return a function collect it's args for g.done\n    func2(args,g())\n    func3(args,g())\n\n##seq##\n\nserial execution of a list of functions.\n\n    ctrl.seq([\n      function (x){\n        ...\n        this.next(null,1)\n      },\n      function (err,x){\n        ...\n        this.next(null,2)\n      },\n      function (err,x){\n    }])(0)\n    \nbut also, custom error handling.\n\n    ctrl.seq([\n      function (x){\n        ...\n        this.next(null,1)\n      },\n      function (err,x){\n        ...\n        this.next(null,2)\n      },\n      function (err,x){\n    }]).error(function (){\n      //handle error\n    })(0)\n\nby default errors are thrown. execution of sequence stops if there is an error.\n\n##curried callbacks ##\n\nthe callback is also added to the end of the argument list.\n\n    ctrl.seq([\n      function (x,next){\n        ...\n        next(null,1)\n      },\n      function (err,x,next){\n        ...\n        next(null,2)\n      },\n      curry(asyncFunction)\n      ])(0)\n\n\n\n\n##defer##\n\nsometimes you have a object that needs an async start up before certain methods are called. \n\n`ctrlflow.defer()` can be used to record async method calls, and play them back when the reciever is ready:\n\n    var async = {}//object to add defurred methods to,\n    var ready = ctrl.defer(async,['do'])//defer(obj,listOfMethodNames) \n                                        //-> returns ready(obj) method, for when functions can be executed.\n\n    //can call named methods on the object.\n    //they will not be executed yet.\n    async.do('hello',function (x){\n      console.log('.do() called back:',x)\n    })\n\n    var __async = {do: function (hi,funx){funx(hi)} }\n    //call ready(ObjectWhichHasRealFunctions) when it's time.\n    ready(__async)\n\n    //from now on, calls will be executed immediately.\n    async.do('goodbye',function (x){\n      console.log('.do() called back again:',x)\n    })\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/dominictarr/ctrlflow/issues"
  },
  "_id": "ctrlflow@0.0.3",
  "_from": "ctrlflow@0.0.3"
}
